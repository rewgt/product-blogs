前端 MVVM 与 FRP 的升阶实践：ReRest 可视化编程
----------

&nbsp;

ReRest (Reactive Resource State Transfer) 是前端开发领域新兴的方法论体系，它继承了 MVVM 与 FRP 编程理念，在技术上有不少创新。本文从专利稿修改而来，主要介绍 ReRest 原理与若干实践经验。

&nbsp;

### 1. 前言

前阵子 React 附加专利条款的开源协议闹得沸沸扬扬，国内外有多家知名企业开始弃用 React，我们也深感困惑，很犹豫是否该将 shadow-widget 全盘改写，让底层脱离 React。但专利与开源协议是并行的两个世界，改底层也不大容易解决问题。Facebook 拥有虚拟 DOM 方面的专利，preact、vue 等都可能涉嫌侵权，通过修改底层代码来规避还是挺难的。

后来我们决定自己申请专利，以便今后万一用到，有个专利可为 shadow-widget 增加话语权。当权利要求书完稿时，Facebook 宣布 React 回归真正的 MIT 开源协议了，这真是天大喜讯，我们不必担心专利的风险了，自个申请专利不再有必要 —— 我们创建 shadow-widget 技术平台，但无意借此盈利，源码开放出来让大家都受益。（PS：不必感谢，如果觉得这项目对您有用，<a target="_blank" href="https://github.com/rewgt/shadow-server">上 github 为我们加星吧</a>）

本文从专利申请稿改写而来，内容有压缩，否则文章太长，另外还增加了可视化编程实践的若干内容。公布此文还有一个目的，防止他人偷偷将我们的技术申请专利，如果以后发现真有人这么干了，本文是个依据，大家可以提请专利无效，把他的保护条款废掉。

说明：本文完稿时，Shadow Widget 最新版本为 v1.1.2，产品用户手册对技术实现有更详细描述。

### 2. 背景

近些年 Web 前端技术发展，可以说是框架横飞的时代，虽然十年前网页还正常能打开，IE 还是那个顽固的 IE，但前端开发却已经历了翻天覆地的变化。近来比较抢眼的是 React 框架，Facebook 开创性的实践了两种技术：虚拟 DOM 与 [Functional Reactive Programming](https://en.wikipedia.org/wiki/Functional_reactive_programming)（FRP，函数式响应型编程），这两种技术是现代前端框架的标准配置，俨然已成不可逆的发展潮流。

Facebook 在虚拟 DOM 上原创较多，钻研很深入，也可以说很成熟了，FRP 在 React 的实现就是那个 FLUX 框架，它不是 Facebook 首创，在 React 中用起来有点磕磕碰碰，尤其在调和指令式风格与函数式风格方面，并不顺畅。

另外，尽管十年来 Web 开发技术发展很快，但在可视化开发方面仍然进展缓慢，所有主流框架都在界面的形式化描述上做文章，Angular 与 Vue 扩展了标签属性，增加不少控制指令，React 则全盘引入 JSX 描述方式，他们无一例外的都要求大家，一行行写代码去定义界面，而不是 20 年前就在 Delphi 与 VB 已出现的可视化开发方式。

本文所提的 ReRest 编程方法，是适应 Web 可视化开发要求，融合虚拟 DOM 与 FRP 技术，并克服这种技术在主流框架的若干不足，而提出的通用型解决方案。ReRest 方法在 [shadow-widget](https://github.com/rewgt/shadow-server) 平台有一些实践，已取得良好效果。

### 3. ReRest 要点

ReRest 全称为 REactive REsource State Transfer，译为 “响应式资源状态迁移”，与本概念相关的提法还有：

1. ReRest framework，ReRest 框架
2. ReRest based programming，基于 ReRest 的编程
3. ReRest design，ReRest 风格设计

从字面上看，“响应式资源状态迁移” 不大好理解，就像缩写为 REST 的 “Representational State Transfer”，表现层状态转移，单看文字，不容易搞清楚讲的是啥。

**ReRest 提倡以 “资源” 的观点展开设计**，将针对资源的操作规格化，统一抽象成 4 类操作，在程序开发过程中，基于 Component 的功能块设计形成一个维度，基于资源状态变迁带来的单向数据流，构成另一维度，两个维度共同形成一个正交矩阵结构，有效平衡了指令式与函数式两种设计风格，集两者优势于一身，并尽量消减两者冲突。

ReRest 理念与 REST 有某种相似性。REST 核心含义是用 URL 定位资源，用 HTTP 描述操作，它要求服务侧提供的 RESTful API 中，只使用名词来指定资源，原则上不使用动词，“资源” 概念可以说是 REST 架构的处理核心，针对资源的操作是 `GET, POST, PUT, DELETE` 等 HTTP 动词。在 ReRest 框架中，界面控件的属性数据视作资源，依据 shadow-widget 实践，“资源（Resource）” 的概念特指 React Component 的属性数据。

基于 ReRest 的编程，须把握两个重点：**Component 管界面呈现，Resource 管数据流**。前者适用静态思维，更偏指令式风格，后者适用动态思维，更偏函数式风格。

![REST](md/res/D171012-01/restful.jpg)

### 4. 两种思维模式

主流的前端框架一直并存静态与动态两种思维模式，举例来说，Vue 与 Angular 更多的静态思维，**界面是可描述的**，React 更多的是动态思维，**界面是可编程的**，JSX 看上去也是一种表述形式，但它本质是一段 javascript 代码，你很难 “去编程化”，把 JSX 从上下文环境抠出来独立使用，事情将变得无意义。

我们不必争论这两种模式孰优孰劣，两者都具备显著优点。F.S.菲茨杰拉德曾说：检验一流智力的标准，就是头脑中能同时存在两种相反的想法，但仍保持行动能力。

况且，在前端开发中，该采用静态思维或动态思维的条件还算清晰，比如开发一个网页，大功能块的界面设计应采用静态思维，比如，在顶部放一个工具条，左侧放导航，中间放内容，简单界面设计应以静态思维为主，因为界面组件很少动态替换，而应对复杂功能，应以动态思维为主，既然 JS 代码可以控制一切，局部界面用 JSX 定义会很爽，越是动态变化的界面，应该越倾向于用动态的、编程性思维。

Angule 静态思维过重，React 动态思维过重，都不好，Vue 从静态走向动态，易用且适应复杂变化，应该说它正前进在正确道路上，只是，Vue 兼容两种风格并非一开始就统筹规划，工具复杂性不容易降下来。

### 5. 从 FRP 到 FLUX，再到 ReRest

ReRest 基于前人经验，在开发实践中总结、验证，提炼、升华而成，其中最重要的技术基础是 React 生态链上的系列工具。

如果只把 React 看作虚拟 DOM 库，它无疑是一项伟大的发明，作为 DOM 节点对应物，可按任意方式使用它，你完全可以在 React 基础上扩展出像 Vue 那样的指令式描述系统，甚到回退到 jQuery 方式去用也行（偷偷告诉你，用 `node.__reactInternalInstance$XXX` 可以反查 Component 的），React 团队在 SoC（关注度分离）方面分寸把握得很好。

虽然 React 工具链普遍顺从浓重的函数式开发风格，从函数式拓展命令式较为容易，但反过来就困难得多。就像许多编程语言，都从 LISP 普系吸收营养，相对来说，函数式编程更反映事物的本原，从此出发更容易理顺具有复杂关系的框架系统。

由于上面原因，ReRest 的实践性探索从 React 开始，而不是 Vue 或其它工具。

#### 5.1 理解 React 的 FRP 机制

FRP 是响应式编程一种范式，由不断变化的数据驱动界面持续更新，界面更新，或用户操作（如鼠标点击等）又产生新的数据流，如此循环往复。触发界面更新的数据流也称事件流，因为它的行为方式有限定，不是常规数据流动，它至少要求单流向、细粒度、按 tick 触发。

我们不妨把网页界面的更新过程，理解成众多 “产生更新动作的时间片” 的集合，一个时间片称为一个 tick，各 tick 前后可能紧挨着，但两个 tick 之间至少都有 “调度间隙”。就像下面 `process2` 函数紧随 `process1` 执行，`setTimeout(process2,0)` 延时 0 秒，让这两函数有 “调度间隙” 区隔。

``` js
function process1() {
  console.log('in process1');

  setTimeout( function process2() {
    console.log('in process2');
  },0);
}
```

数据变化导致界面更新（即 React 的 `render()` 调用），而界面更新又触发数据变化，如果没有调度间隙，系统可能陷入无限递归，无限递归结果必然爆栈。React 的 FLUX 框架首先要让数据单向流动，注意，即使数据变化与界面更新无限制的互为触发，只要有 “调度间隙” 区隔，都算单向流动。

React 以两种机制保障数据单向流动，一是 props 属性只读，二是 `setState()` 延后一个调度间隙执行。后者好理解，前者 “props 只读” 是间接起作用的，因为 props 与 state 同时决定 Component 界面如何表现，但更改 props 属性只能在父节点的 `render()` 函数中进行，你得用 `ownerComp.setState()` 触发父节点再次 `render()`，所以，不管怎么用，仍会插入 “调度间隙”。

此外，React 要求在 `shouldComponentUpdate()` 中结合各属性的 immutable 是否变化，来决定是否触发 render 更新。这些机制支持了 FRP 的编程要求：按时间切片驱动界面更新，各切片保持细粒度，每次更新最小化、无关联。

#### 5.2 改造双源驱动

由父节点决定如何更新的 `props.attr` 与本节点自己决定的 `state.attr`，共同定义 Component 界面表现，props 与 state 合称双源，只是原生 React 系统是 “隐式双源”，ReRest 框架要把它改造成 “显式双源”。

实现原理大致如下：

1. 引入与 `props.attr` 及 `state.attr` 对等的集合：`duals.attr`   
该集合下的 `attr` 把 `props.attr` 自动登记为 `state.attr`，通过 `duals.attr` 操作接口，等效实现对相应 `state.attr` 的读写，即：读操作 `duals.attr` 等效于读 `state.attr`，写操作 `duals.attr = value` 等效于执行 `this.setState({attr:value})`。

2. 提供 `this.defineDual()` 让用户手工注册 duals 属性   
系统还将传入的标签内置属性（如 `name,href,src` 等）自动注册为 duals 属性，此举方便了编程，否则大量属性手工注册很麻烦。

3. `defineDual()` 支持捆绑 setter 回调   
比如调用 `this.defineDual('a',setter)` 注册后，对它赋值 `this.duals.a = value`，将自动触发 `setter(value,oldValue)` 回调。

经此改造，更改 Component 自身 props 属性不必转绕到父节点去做，比如，用`comp.duals.name = 'new_name'` 直接赋值就好。

这么变动带来一个重大影响，**上层 FLUX 机制可以捊直了做**。如何实现 FLUX，官方给出了框架建议，React 说我只管虚拟 DOM，如何搭 FLUX 是上层的事，Redux 说，我来管这事，增加 action，增加 reducer，增加 store，不过异步的事你自己解决。什么是 action 呢？就是事件化数据，什么是 reducer 呢？就是事件处理函数，什么是 store 呢？那个 Component 限制了数据读写，还搞不清子节点、父节点在哪，我就自个弄一数据集。结果 Redux 绕了很大一个弯，说把事情解决了，但用户仍报怨写异步很难受呀，这么绕的东西不难受就鬼了。

ReRest 的对策很简单，最直接。事件化数据就是可侦听的 duals 属性嘛，事件处理函数就是 duals 的 setter 回调，理不清父子从属关系，就弄一个 W 树，把各节点串起来，用 `this.componentOf()` 以相对路径或绝对路径直接找，至于 store，哪有必要，Component 自身就是 store 嘛！

#### 5.3 资源化

ReRest 尝试让 Web 开发回归本原，网页开发主要处理两样东西：开发界面、与服务器交换数据，它与 Delphi、Qt 等 GUI 开发工具不该有太大差别，为什么 React 就不能支持 MVVM 呢？MVC 难以适应标签化的界面描述形式，但 MVVM 没问题。

常规的所见即所得开发工具，界面设计主体过程是：拖入一个样板创建界面组件，然后选择配置某些属性，再拖入样板，设属性，重复操作直至组装出复杂界面，外观设计差不多就这些，剩下工作主要是功能实现，实现诸如接收输入，响应按钮点击等动作函数。

原生 React 之所以远离常规可视化设计，主要是 Component 属性成员级别的设计还不够好，少一层静态可依赖的锚点，直接套上高度变迁的事件流机制了，所有东西都动态可变，可视化设计是无法支持的。在 ReRest 设计理念中，Component 属性中公开供控制，或供配置的，都应视作 “资源”，“资源” 是静态化的概念，就像 RESTful 要求 URL 要用名词表达资源，动作统一由 HTTP 的 `GET, POST, PUT` 等表达一样，将 Component 属性 “资源化”，才是问题解决之道。

就 shadow-widget 实践而言，**ReRest 所谓的资源，专指 Component 的静态属性（即 `comp.props.attr`）与双源属性（即 `comp.duals.attr`）**。

React 对 Component 节点的渲染组装在 render 函数中完成，组装过程是一段 javascript 代码，因为 JS 代码可以任意书写，组装实现非常灵活。而灵活是一把双刃剑，功能虽然强大了，但缺少稳定形态，对建立 MVVM 框架与可视化开发都不利。

ReRest 希望将渲染过程，改造成只依赖于对 “资源” 的操作，当然，这里的 “资源” 是动作化了的，也就是，读写资源会自动触发预设的关联处理。换一句话来说，ReRest 想把 render 函数改造成一种固定格式，不再通过写一段过程处理代码来定制，而改成对若干 `duals.attr` 读写，以此驱动渲染过程的定制处理。

ReRest 渲染过程的 “资源化” 改造，本质是将过程控制逻辑，挪到 “资源” 附属的动作函数中书写。

#### 5.4 渲染临界区

如下示例：

``` js
01 render() {
02   // 进入渲染临界区
~~   渲染临界区的过程处理 ...
04   // 退出渲染临界区
05 
~~   固定程式的其它 render 处理 ...
07 }
```

“渲染临界区” (Rendering Critical Section) 中的代码（上面 03 行）用来驱动本 Component 各个 `duals.attr` 附属动作。上面 06 行，让附属动作处理后的结果生效，完成渲染输出。经此改造，用户不必再定义各 Component 的 `render()` 函数。

在 “渲染临界区” 执行的代码有特别要求，其一，render 函数由 React 内核发起，render 过程中再次触发更新、用 `ReactDOM.findDOMNode` 查找 node 节点等有限制（说明：随着 React 版本不断优化，这类限制越来越少，目前最新版本在 render 函数中调用 `findDOMNode` 不再报错了）。其二，ReRest 资源的行为函数如何被调用，在临界区中与临界区外有差别，下文马上介绍。

#### 5.5 资源的行为定义

ReRest 分两类资源，只读资源（即 `comp.props.attr`）与可写资源（即 `comp.duals.attr`），对于前者，在 Component 生存周期内，只支持 “读” 行为，而对于后者，支持读、写、setter 处理、listen 处理共 4 种行为。

<div $=".body.auto1.res"></div>

四种行为介绍如下：

1. 读   
从 `props.attr` 直接读取，或读取 `duals.attr` 时，系统自动返回 `state.attr` 的值。

2. 写   
对 `duals.attr` 赋值，系统除了把值赋给 `state.attr` 外，还触发相应的 “setter处理” 与 “listen处理”。

3. setter 处理   
这个 setter 就是 `defineDual(attr,setter)` 的 `setter` 回调函数。对于同一 Component 的同一 attr，可以调用多次 `defineDual()` 注册多个回调函数，给 attr 赋值后，各回调函数依次调用，调用顺序与注册顺序相同。

4. listen 处理   
对一个已存在 `comp.duals.attr`，可调用 `comp.listen(attr,fn)` 登记侦听，当 attr 值发生变化后，系统会自动调用 `fn(value,oldValue)`。同一 `comp.duals.attr` 支持在多处侦听，为两个（或多个） `duals.attr` 建立侦听关联，一处更新，其它地方也联动更新。

setter 处理与 listen 处理的适用场合有明显差异，setter 函数只在渲染临界区的处理过程中被调用，listen 函数必定延后一个 “调度间隙” 被执行，而且必然不在任何节点的渲染临界区内。

同一节点的渲染临界区内，setter 函数可被连续调用，当前节点下不同 `duals.attr` 或同一 attr 的 setter 可串连着执行，这意味着，临界区内对当前节点 `duals.attr` 赋值可能引发递归重入，各次 setter 调用之间没有 “调度间隙” 区隔。比如 `comp1.duals.attr1` 修改，导致 `comp1.duals.attr2` 与 `comp2.duals.attr3` 修改，而 `comp1.duals.attr2` 修改可能再导致 `comp1.duals.attr1` 修改，这时对 `comp1.duals.attr1` 赋值可能导致该属性的 setter 函数递归调用，而引发的 `comp2.duals.attr3` 更改是延后一个 “调度间隙” 的，因为 comp2 的双源属性 setter 函数将在 comp2 的临界区被调用。

**setter 与 listen 处理反映了两类资源联动的需求**，常规情况下，隔一个 “调度间隙” 可确保数据单向流动，而特殊情况下，对于紧密相关的资源联动，如果总有 “调度间隙” 隔着，显然会影响运行效率，上述机制保留了重入式 setter 回调的可能。

### 6. 范式变换

Redux 是 React 生态链中提供 FLUX 框架的一个典型工具，有代表性，它以 “Action” 的观点展开设计（其它 FLUX 工具也大都如此），ReRest 则要求以 “Resource” 的观点展开设计，Action 是动态的动作，Resource 是静态的资源，两者差别可用 “非 RESTful” 风格与“RESTful” 的差别来类比。

基于这两种观点的设计存在范式变换关系，下面我们用 Redux 与 shadow-widget 的 FLUX 实现为例，展开说明。

#### 6.1 单 Store 变多 Store

拿 Redux 用户手册提到的 Todo 例子来说，增加一条 todo 记录，基于 Action 观点会先设计一个 Action 定义：

``` js
const ADD_TODO = 'ADD_TODO';

var actTodo = {
  type: ADD_TODO,
  text: 'Build my first Redux app'
};
```

然后，设计一个 reducer 响应这个 Action：

``` js
function todos(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [ ...state, {
        text: action.text,
        completed: false,
      }];
    // ...
  }
  // ...
}
```

Redux 采用单一的大 Store 结构，ReRest 要求的资源是小数据，相当于把 Redux 的大 Store 分割成许多小块，一个小块就是一个资源。针对 todo 列表，定义这么一项资源：`duals.todoList`，指定它的初值是空数组。

``` js
this.defineDual('todoList',null,[]);
```

然后用如下代码添加一条 todo 记录，就对等实现上述 reducer 功能：

``` js
utils.update(this,'todoList', {$push: [{
  text: 'Build my first Redux app',
  completed: false,
}]});
```

ReRest 的 Store 具备两个特点：
1. 采用多 Store（与 reflux 类似），Store 实体与 Component 重合。
2. 由于数据流动设计针对 Component 下的属性展开，为方便理解，ReRest 的 Store 也可视为双层结构，第一层是 Component 实体，第二层是 Component 下视作 resource 的属性定义，包括 `props.attr` 与 `duals.attr`。

Component 下的 resource，本质是数据，与 Store 同属一类，Redux 的 reducer 在 ReRest 中转成 4 种资源行为定义，而 Redux 的 Action 弱化成一条操作资源的常规语句。强调一句，Redux 设计用 Action 提纲挈领，ReRest 设计用 Resource 提纲挈领，弱化 Action 是很自然的事，因为相关操作可以随时添加，抓住数据定义才是核心本质。给 Action 指定一个常量名，再定义 Action 结构，然后用 `switch..case` 到处判断 `action.type`，没人觉得烦吗？

#### 6.2 数据定义用作事件

侦听一个 `duals.attr` 后，侦听函数就是事件处理函数，FLUX 要求 Dispatcher 可以简化，比如我们用 `duals.receivedData = data` 表示已接收外部一条指定，对它赋值即触发侦听它的事件处理函数被调用。

对 `duals.receivedData` 赋值结果如果没有变化，系统将忽略触发侦听函数。若不想忽略，调整一下数据定义，比如用 `duals.receivedData = [data,ex.time()]` 加一个时间戳，就保证每次对 `duals.receivedData` 赋值，都能触发侦听函数了。

尽管 ReRest 聚焦于如何配置资源，`duals.attr` 的组织形式很简单，却完整支持事件流机制，包括多源头侦听，等全部事件来齐再触发回调函数，例如：

``` js
utils.waitAll(comp1,'attr1',comp2,'attr2', function(value1,value2) {
  // do something ...
});
```

#### 6.3 渲染器

如果一个节点的结构比较稳定，比如它渲染输出的标签名不变，其子节点构成也不变，这时，对该节点的属性做 “资源化” 改造是很容易的。但如果节点结构不是稳定的，我们还得另寻方法实现资源化定义，解决对策便是 “渲染器”。

React 中一个节点有效的内容组装在 `render()` 函数进行，由 `comp.setState()` 驱动`render()` 函数反复调用。render 是动作，按资源化方式理解，把它变名词，是 rendering，就是渲染器，我们假想 `render()` 由一个渲染器驱动，渲染器内部用一个计数器（记为 `id__`）控制渲染刷新，比如：`comp.duals.id__ = 2` 赋值会导致 `render()` 自动被调用，运行 `comp.setState({attr:value})` 也促使 `render()` 被调用，而且 `id__` 自动取新值。也就是说，每次 `render()` 运行，渲染器的计数器都会取不同值，都等效执行了 `duals.id__ = value` 语句。

如下注册 `duals.id__`：

``` js
01 this.defineDual('id__', function(value,oldValue) {
02   // this.state['tagName.'] = 'div';
03   // this.state.attr1 = xxx;
04   // this.duals.attr2 = xxx;
05   
06   // prepare jsx_list ...
07   // var jsx_list = [ <SomeTag ...props> ... </SomeTag> ];
08   
~~   // utils.setChildren(this,jsx_list);
10 });
```

上述渲染器 `duals.id__` 的 setter 函数，称为 idSetter 函数，这种以 “渲染器资源” 指代 `render()` 渲染过程的定义形式，称为 **idSetter 定义**。

在 idSetter 函数编写代码，等效于在 `render()` 编程，可以随意组装子节点，用 `utils.setChildren()` 设进去。还可修改当前节点的 `state.attr, duals.attr`，甚至节点的标签名也可以改，如上面 02 行代码。

借助 `duals.attr` 的资源形式，包括 `duals.id__` 渲染器，ReRest 实现了 `render()` 渲染过程的范式变换。已有实践表明，基于 ReRest 的编程与 React 原生方式等效，表达能力几乎等同。

### 7. 可视化设计与 MVVM 框架

为了支持可视化编程，像 JSX 这种与 javascript 代码混写的界面描述方式需要改进，因为界面设计应独立进行。在可视化设计器中，被设计的界面不能像产品正常运行那样表现功能，鼠标点击在设计器中表示选择一个构件，而对于正式运行的产品功能，可能是按钮点击、跳转链接点击等，所以，**基于 ReRest 的编程，要求我们改用一种可选绑捆功能定义的界面描述方式**。

在 shadow-widget 实践中，我们采用 “转义标签” 来描述界面，而界面的功能实现在投影类或 idSetter 函数中实现，这两者分开定义。产品正常运行时，在页面导入初始化阶段，两者自动捆绑，让类似 onClick 在 javascript 实现的功能定义，与用 “转义标签” 描述的界面结合。但在可视化设计状态，功能定义缺省被忽略（注：也可以不忽略，但要用特殊方式定义）。

所谓 “转义标签”，就是用类似 `<div $=Ul>desc</div>` 的方式描述 “非 inline” 标签 `<Ul>desc</Ul>`，或用类似 `<span $=Button>title</span>` 描述 inline 标签 `<Button>title</Button>`。“投影类” 与 “idSetter 定义” 等效，都用来定义 Component 节点的行为。限于本文篇幅，这三项我们不展开介绍。

前面介绍的资源化改造，还支持 MVVM 框架在 React 体系得以实现，MVVM 要求数据属性能够双向绑定，`duals.attr` 的 `getter/setter` 机制支持了此要求。如下图，ViewModel 就是投影定义与 idSetter 定义，View 是各 Component 从虚拟 DOM 反映到真实 DOM 的界面表现，而 Model 是数据模型，对于前端开发，Model 通常很简单，一般就是各 Component 的 `props.attr` 与 `duals.attr` 规格定义，只有少数需对数据做转换、存盘、备份等处理的，才会额外设计一个 Model 实体。

![MVVM](md/res/D171012-01/mvvm.jpg)

MVVM 可视为 MVC 框架在前端环境的最佳适配，它也是可视化设计的基础。可视设计的主体过程是在创建 Component 构件后，在线设置它的 `props.attr` 与 `duals.attr` 属性值。正因为 MVVM 中 ViewModel 是双向绑定的，属性取值与界面表现才自动保持一致，这也是 MVC 框架无法适应前端可视化开发，而 MVVM 适应得很好的主要原因。多说一句，属性取值与界面表现并非简单的直接对应关系，而是属性取值要关联一系列变化，须有自动 setter 调用的机制才行，举例来说，设置一个按钮的 `duals.disabled` 为真，不止设置 DOM 节点的 `disabled` 属性，还要让按钮外观变灰，再改换 `cursor` 配置为 `"not-allowed"`。

### 8. 函数式风格

相比 Angular 与 Vue，React 生态链上各工具普遍追纯正的函数式开发，这既与 React 团队倾向性推动有关，也与 React 体系的技术特征有关，越倾向函数式开发就越适应它的 FLUX 框架模型。

#### 8.1 函数式是 FRP 编程的天然姻亲

FLUX 框架是 FRP 编程理念（Functional Reactive Programming）的一类实现，它的一个重要技术路径是，以 CPS 风格（Continuation-Passing Style）应对响应式接续处理，函数式编程正是 CPS 变换的最佳载体。

举一个简单例子，如下提供 Email 输入，当输入内容不合邮箱格式时，右侧图标出现告警图标，底部还有详细提示。

![Input email](md/res/D171012-01/input_email.png)

响应式编程的做法是，用户持续输入文本，内容是否合规随即校验，校验与输入同时进行，校验结果并不打断输入操作。这么理解，手工输入形成持续的数据流，各次数据都驱动校验处理，校验对于输入来说是异步进行的。假定用户输入合法的 Email 地址后，系统用它自动向服务器查询信息，比如得到用户别名、上次登录时间等，这些信息用来辅助于下一步表单填写。这么编码：

``` js
~~ comp.listen('validation', function(value,oldValue) {
02   if (value == 'success') {
03     var sEmail = comp.duals.email;
04     utils.ajax( {
05       url: '/users/' + encodeURIComponent(sEmail),
~~       success: function(data) {
07         // ...
08       },
09     });
10   }
11 });
```

这里 01 行与 06 行调用都是 CPS 风格，实际调用虽是异步，但代码写一起，上下文变量共享。这种代码风格在响应式编程中大量使用，因此，函数式是 FRP 编程的必然选择。

#### 8.2 ReRest 中的函数式编程

虽然 “资源” 是静态化的概念，但 ReRest 对资源的动作定义，仍是适用 CPS 的函数方式，并未破坏整体函数式风格。简单这么理解，前面所提 ReRest 的资源化，实质是提供了 **带锚点的函数式编程**，锚点依附于 Component 实体而存在。所以，在可视设计器中，创建 Component 后，资源锚点（即 `props.attr` 与 `duals.attr`）就存在了，所见即所得的在线配置因此成为可能，这相当于，ReRest 在原设计基础上，插入一排方便思考，易于可视设计的抓手。

用来实现 Component 功能定义的投影类，以对象方式编码，属于命令式风格。提供与之对等功能的 idSetter 定义，则是函数式的，如下举例：

``` js
this.defineDual('id__', function(value,oldValue) {
  if (oldValue == 1) {
    // init process just after all duals-attr registed
  }
  
  if (value <= 2) {
    if (value == 1) { // init process, same to getInitialState()
      // this.setEvent({$onClick:fn});
      // this.defineDual('attr',fn);
      // ...
    }
    else if (value == 2) { // same to componentDidMount()
      // ...
    }
    else if (value == 0) { // same to componentWillUnmount()
      // ...
    }
    return;
  }
  
  // other render process ...
});
```

前面已介绍 idSetter 如何组装渲染内容，既然渲染器每次计数变化代表一次渲染调用，那能不能留出几个特殊计数值表示 Component 的状态变呢？如上面代码，idSetter 函数确实这么做了，计数值为 0 是初始状态，变为 1 是 Component 的双源属性尚没准备好的初始化状态，相当于 `getInitialState()`，变为 2 是 `componentDidMount()` 被调用的状态，再变回 0 表示马上要回到初态，对应于 `componentWillUnmount()`。这样，一个完整的 React Class 定义，我们用一个 idSetter 函数就表达了。

idSetter 函数既适应可视化设计时界面描述与功能定义分离，还适应函数式编程。当有多层 Component 嵌套时，你可以将里层 Component 的行为定义任意 “Lifting State Up” 到外层 Component 的函数空间。 

#### 8.3 Lifting State Up

采用 JSX 描述界面时，行为定义与虚拟 DOM 描述混在一起，这时仅依赖 props.attr 逐层传递实现数据共享方式，用起来很不方便。React 官方介绍提供一种 “上举 State” 的解决方案，以输入温度值判断是否达到沸点为例，参见 [Lifting State Up](https://facebook.github.io/react/docs/lifting-state-up.html)。

上举 State 用在 ReRest 编程中，除了收获 React 官方所提几个好处，还有两项特别收益。其一，原有 React 基于过程组织渲染内容，ReRest 的主体是基于 `duals.attr` 驱动渲染，跨节点 listen 更容易，处理逻辑也更清晰；其二，定义节点行为的 idSetter 是函数，原生 React Class 定义要用 `class MyClass extends React.Component {}` 方式，层层嵌套定义时，肯定没有 idSetter 用得方便。

仔细琢磨 “Lifting State Up” 方案，大家不难发现，上举 State 解决了部分 Reflux 或 Redux 已支持的需求，被上举共享的 state 其实也是一种 Store。

### 9. 可视化设计实践

ReRest 编程在 shadow-widget 平台的实践已持续一年多时间，在多个项目应用了 ReRest 编程，较典型的有 [pinp-blog](https://github.com/rewgt/blogs) 与 [shadow-bootstrap](https://github.com/rewgt/shadow-bootstrap)。在一年多时间里，shadow-widget 也在 ReRest 实践推动下不断完善，尤其是 idSetter 与可计算表达式，优化幅度较大。

在接下来几节，我们补充介绍前文尚未涉及的，与实践相关的若干知识与编程体验。

#### 9.1 正交框架分析模式

先介绍 “功能块” Functionarity Block（简称 FB）的概念，一组 Component 合起来提供某专项功能，称为一个 FB。取上面提到 Lifting State Up 判断温度是否达到沸点为背景，我们可以开发两个功能块，其一是配置格式（config FB），用来配置当前用摄氏 Celsius 还是华氏 Fahrenheit 作单位，其二是计算沸点（calculator FB），提供输入框，判断输入温度是否达到沸点。

后一 FB 的界面如下：

![计算沸点](md/res/D171012-01/is_boil.png)

编写 FB 代码块如下：

``` js
(function() { // functionarity block: calculator

var scaleNames = { c:'Celsius', f:'Fahrenheit' };
var selfComp = null, verdictComp = null;

idSetter['calculator'] = function(value,oldValue) {
  // ...
};

})();
```

一个 FB 宜用一个函数包裹，主要为了构造独立的命名空间（Namespace），本功能块内共享的变量在这个地方定义，比如上面代码中 `scaleNames, selfComp, verdictComp` 变量，把命名空间独立出来，也防止 FB 内部使用的变量污染外部全局空间。

既然一个 FB 内某些 Component 很常用，把它定义成 FB 内共享的变量更方便。

``` js
var selfComp = null, verdictComp = null;

idSetter['calculator'] = function(value,oldValue) {
  if (value <= 2) {
    if (value == 1) {      // init
      selfComp = this;
      // ...
    }
    else if (value == 2) { // mount
      verdictComp = this.componentOf('verdict');
      // ...
    }
    else if (value == 0) { // unmount
      selfComp = verdictComp = null;
    }
    return;
  }
};
```

产品开发明显有两个阶段：界面可视化设计与功能实现，在前一阶段，先规划有哪些 FB 功能块，再针对各 FB 设计界面，按用户使用习惯逐级摆放各层构件，各层构件都是 W 树中节点。以上述 config 与 calculator 功能块为例，我们画出 FB 分布为横轴，W 树为纵轴的示例图。

![正交矩阵](md/res/D171012-01/fb_w.png)

之后进入开发第二阶段：功能实现。这时要实现数据在 FB 之间如何流动，前一功能块 config 配置当前采用哪种温度格式，记录到 `duals.scale`，后一功能块 calculator 根据自身 `duals.scale` 指示来显示界面，并决定用 100 度还是 212 度判断沸点，两个 scale 属性的数据流向如下图所示，我们只需让后一 `duals.scale` 侦听前一 `duals.scale`，让两者维持同步即可。

![数据流分析](md/res/D171012-01/dataflow.png)

本处举例比较简单，复杂些产品的设计过程也大致是这几个步骤。总结一下，整个 HTML 页面是一颗 DOM 树，是纵向的（上图纵轴），将这颗树划分为若干 FB 功能块（上图横轴），划分过程主要依据 MVVM 逐步拆解；而处理各功能块之间的横向联系，则以 FRP 思路为主导。这一纵一横的思考方式，我们称为 “正交框架” 分析模式。

可视化设计时，提供在线配置的最小单位是各 Component 的 `props.attr` 与 `duals.attr`，就是 ReRest 所说的 “资源” 项。而处理各 FB 之间数据如何流动的思考起点，也是这类 “资源” 项，MVVM 与 FRP 的交汇处正是 ReRest 资源化的落脚点。

#### 9.2 Component 属性定位有变化

`props.attr` 是只读的，用来驱动本节点组织渲染数据，凡涉及状态变化的要用 `state.attr`，然后同样用 props 驱动子级节点内容更新。现有 React 生态链上各类工具对 `props.attr` 定位似乎只有两项：一是用作 Component 的入口驱动数据，二是以只读特性确保数据单向流动。

shadow-widget 对 props 与 state 的使用定位做了优化。其一，用 `duals.attr` 表达一个 Component 对外公开的控制接口，不再建议用 `setState()` 动态更新 “非自身节点” 的数据了，相应的 `state.attr` 也收缩成只供 Component 内部编程时使用，类同于私有变量。其二，`props.attr` 用作入口数据的定位没变，但刨去转换成 `duals.attr` 与事件函数，剩下的常规属性被看作生存周期内的常量，在节点 unmount 前不会变化。

这两点定位调整的背后有深刻原因，开发理念发生变化了。在 React 提供的虚拟 DOM 库级别，各 Component 的所有属性都是对等的，无差别，虚拟节点无需识别各属性项的语法含义，这么处理没问题，因为底层库只聚焦节点虚拟化。但对于上层应用，需要区分各属性的语义，**现实应用中，各节点总具备一定 “性状” 的**。比如，你想表达一段文本就创建 `<p>` 节点；如果创建了 `<ul>` 节点，也意味着你将在它下面挂入 `<li>` 节点；如果创建 `<input>` 节点，通常连带 `type` 属性也算作 “性状” 一部分，`type='text'` 文本框，`type='checkbox'` 是选项框，两者形态差异巨大，文本框要用 `node.value` 表示输入值，选项框则用 `node.checked`。

所以，**上层应用宜将各节点的固有性状，视作生存期内不变的常量，动态变化的纳入 duals，用作控制量**。反之，如果不承认节点固有性状，就不会有 MVVM 框架形式，可视设计器也无支持通过拖入样板来创建 Component，假设你创建的是 `<table>` 节点，改改属性就把它变成 `<ul>` 列表，可视化设计没法做了。

shadow-widget 还将 `className` 分割成 `className` 与 `klass` 两个属性，用 `className` 表达固有类定义，在构件的生存期内不变，用 `klass` 表达可变的状态量。

#### 9.3 父子结节的单向依赖

我们先看一个事实，Bootstrap 提供的 50 多个组件中，大部分由多层节点构成，或者使用时要求与其它组件搭配，用一个节点表达完整功能的只是少数，而且都只提供简单功能，像 Label、Badge 等，这类组件约占总量的十分之一。可以说，现实中的前端开发，父子 Component 组合是常态，是主流。

Shadow Widget 有很多机制让父子节点关联起来，主要有：

1. 把所有存活的构件（已挂载且未卸载）串接成一颗 W 树，树中各节点能方便的互相引用
2. 提供导航面板把多个构件封装起来，形成一组，组内构件用 `"./"` 相对路径索引
3. 上面提到 FB 功能块的编码，建立块内共用 Namespace，让功能紧密相关的父子节点共享变量
4. 用 `$for, $if, $else` 等指令描述动态节点，层层嵌套的 callspace 支持在下级节点直接引用上级各层节点的各种属性
5. 支持 `$trigger` 机制触发相邻节点的动作定义

React 让 props 属性只读的深刻根源，**是要解决数据依赖性**，解决依赖性的同时顺带保障数据在父子节点之间单向流动。节点创建有先有后，具有从属关系的两个节点，子节点必然在父节点之后创建，并且 unmount 必在父节点之前，也就是，子节点依赖于父节点而存在，子节点的数据也依赖于父节点的属性先赋值。所以，React 设计了数据传递要借助 props 逐层进行，原则上属性数据跨层不可见（先撇开 context 不谈，那是补救性设计，官方并不推荐你用）。

子节点依赖于父节点，但反过来不是，依赖是单向的，但 React 生态链上诸多工具，都按 “隔绝依赖” 来处理了，相当于忽略依赖存在。举例来说，比方我们要设计下图 DropdownBtn 与 SplitBtn 两种按钮，两者功能基本一样，外观有差别，怎么实现呢？

![DropdownBtn 与 SplitBtn](md/res/D171012-01/dropdown.png)

外层节点用 `props.isSplitBtn` 指示按钮是否为 SplitBtn，然后里层节点根据 `isSplitBtn` 取值，绘制不同外观的按钮。如果按 “隔绝依赖” 来处理，只能借助 props 层层传递 `isSplitBtn`，隔了几层就传递几层，如果按 “单向依赖” 来处理，里层哪个节点需要要区分 `isSplitBtn`，就往上层查找，看看 `props.isSplitBtn` 取什么值。这两种处理方式差别很大，前者忽略了主从构件的天然关系，以暴露接口的代价实现功能，把无关节点都牵扯进当来传手，就像打排球的一传、二传、三传，在功能组合较多时，显得很绕。

从子节点向上查找，分析一级或多级父节点的属性特点，从而确定它自身所处的场景，进而让当前节点应对不同场景表现不同功能。我们管这种场景推导过程叫 **“场景自省”**，如上介绍，向上追溯的场景自省是安全的，因为子节点若存活，父节点必然还存活，反过来从父节点查子节点则不行。

#### 9.4 不绕弯也能提高生产力

现有 React 生态链上诸多主流工具都很绕，不像 shadow-widget 那么直接，主要表现以下几个方面。

![绳结](md/res/D171012-01/rope.gif)

其一，主流工具普遍忽视父子节点的主从关系是隐含丰富信息的，把所有 Component 摆同等位置来解决跨节点数据传递问题。

源头在于 Facebook 官方的 FLUX 框架有缺陷，FLUX 在虚拟 DOM 的上层实现，但它继续无视 Component 属性带语义特性，无差别对待，借助 Dispatcher 分发 Action，构造独立的 Store，统一处理各 Action 消息。另设 Store 与 Action 另行驱动的过程，相当于换个地方重建各节点的场景信息。

其二，这些工具普遍过于依赖函数式风格，静态化概念只停留在 Component 层面，没往下探一层。各 Component 互相关联，形成网格，这网格直接用函数式编程去编织了。代码量没减，该做的事情一件不少，各个处理环节衍生出不少概念，比较绕。基于 ReRest 的编程则将 Component 下的属性视作资源，静态化概念深入一层，然后在 “资源粒子” 层面，用函数式风格编织网格。直接了当，也符合开发者思考习惯。

shadow-bootstrap 项目按 ReRest 去实践的，核心功能是将 Bootstrap 往 shadow-widget 平台适配。与之类似，业界还有一个知名项目 [react-bootstrap](https://github.com/react-bootstrap/react-bootstrap)，把 Bootstrap 往 React 适配。这两个项目的功能基本对等，封装的组件几乎能一一对上，如果对比两者源码，shadow-bootstrap 显然简洁的多，react-bootstrap 免不了绕来绕去，最终 minify 后，前者 103 Kb，而后者 213 Kb，整整多出一倍。前者开发只用一个多月，后者远不止这个投入，当我们的框架没那么绕时，生产力是大幅提升的。

### 10. 总结

长期以来 GUI 工具与 Web 前端开发工具是两条独立主线，并行发展。MFC、Delphi、VB、WxWidget、Qt 等归入 GUI 开发工具，没人将前端开发也纳入 GUI 开发，不过业界也没人否认前端开发主要工作是设计图形用户界面（Graphical User Interface），就目的而言，前端开发也是 GUI 开发。

这两条主线靠拢发展的时代已来临，虚拟 DOM 技术结合 FRP 理念，再结合 ReRest 资源化改造，MVVM 框架 ———— 对应于主流 GUI 工具所用的 MVC，其可视化开发实践就走通了。ReRest 方法论推出，可以让前端开发回归到 GUI 开发序列，ReRest 实践已在 shadow-widget 走出第一步，希望这一步对 Web APP 与 Native APP 走向融合提供可借鉴经验。

&nbsp;

（本文完）

&nbsp;
<!-- SLIDE PAGES V1.0, DO NOT CHANGE THIS LINE. -->
<div $=ScenePage key='auto0'></div>
<div $=ScenePage key='auto1' no-show='1'>
  <div $=".pinp.doc_info.thumb" sty__='{{"background":"url(md/res/D171012-01/thumbnail.jpg) no-repeat center","backgroundSize":"100% 100%"}}' no-show='' left='{-457}' top='{-216}' klass='default-large-small p1-p2-p3-p0 visible-auto-hidden default-align_center-right' data-group.optid='pinp/blogs/step4' width='{280}' height='{200}'></div>
  <div $=rewgt.DrawPaper key='res' sty__='{{"zIndex":"-998"}}' data-group.optid='pinp/blogs/step0' klass='default-large-small S5' width='{375}' height='{255}' left='{-113}' top='{-221}' def-id='_1507803644'>
    <div $=rewgt.SvgPanel key='auto3' sty__='{{"strokeColor":"#888","fillColor":"#eee"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{15}' top='{18}' width='{136}' height='{56}' svg.cfg='{[0,[],"lib/res/ellipse.svg.json"]}' stroke='{1}'>
      <pre $=MarkedDiv key='txt' width='{0.9999}' klass='default-large-small p1-p2-p3-p0 align_center-right-default'>读</pre>
    </div>
    <div $=rewgt.SvgPanel key='auto4' sty__='{{"strokeColor":"#888","fillColor":"rgb(170, 212, 255)"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{128}' top='{103}' svg.cfg='{[0,[null,[["auto9",-2,"auto5"],["auto11",-2,"auto6"],["auto13",-2,"auto3"],["auto15",-2,"auto7"]]],"lib/res/rect.svg.json"]}'>
      <pre $=MarkedDiv key='txt' width='{0.9999}' klass='default-large-small p1-p2-p3-p0 align_center-right-default'>资源</pre>
    </div>
    <div $=rewgt.SvgPanel key='auto5' sty__='{{"strokeColor":"#888","fillColor":"#eee"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{220}' top='{18}' width='{136}' height='{56}' svg.cfg='{[0,[],"lib/res/ellipse.svg.json"]}' stroke='{1}'>
      <pre $=MarkedDiv key='txt' width='{0.9999}' klass='default-large-small p1-p2-p3-p0 align_center-right-default'>写</pre>
    </div>
    <div $=rewgt.SvgPanel key='auto6' sty__='{{"strokeColor":"#888","fillColor":"#eee"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{222}' top='{176}' width='{136}' height='{56}' svg.cfg='{[0,[],"lib/res/ellipse.svg.json"]}' stroke='{1}'>
      <pre $=MarkedDiv key='txt' width='{0.9999}' klass='default-large-small p1-p2-p3-p0 align_center-right-default'>listen 处理</pre>
    </div>
    <div $=rewgt.SvgPanel key='auto7' sty__='{{"strokeColor":"#888","fillColor":"#eee"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{17}' top='{175}' width='{136}' height='{56}' svg.cfg='{[0,[],"lib/res/ellipse.svg.json"]}' stroke='{1}'>
      <pre $=MarkedDiv key='txt' width='{0.9999}' klass='default-large-small p1-p2-p3-p0 align_center-right-default'>setter 处理</pre>
    </div>
    <div $=rewgt.SvgPanel key='auto9' sty__='{{"strokeColor":"rgb(119,119,119)","fillColor":"rgb(170, 212, 255)","zIndex":"-1"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{216}' top='{65}' width='{84}' height='{70}' stroke='{1}' svg.cfg='{[-2,["",0,0,2,0,49,36,39,60,0],"lib/res/arrows.svg.json"]}' data-from='auto4'></div>
    <div $=rewgt.SvgPanel key='auto11' sty__='{{"strokeColor":"rgb(119,119,119)","fillColor":"rgb(170, 212, 255)","zIndex":"-1"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{216}' top='{111}' width='{86}' height='{74}' stroke='{1}' svg.cfg='{[-2,["",0,0,2,0,0,37,11,62,53],"lib/res/arrows.svg.json"]}' data-from='auto4'></div>
    <div $=rewgt.SvgPanel key='auto13' sty__='{{"strokeColor":"rgb(119,119,119)","fillColor":"rgb(170, 212, 255)","zIndex":"-1"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{71}' top='{65}' width='{69}' height='{70}' stroke='{1}' svg.cfg='{[-2,["",0,0,2,45,49,18,39,0,0],"lib/res/arrows.svg.json"]}' data-from='auto4'></div>
    <div $=rewgt.SvgPanel key='auto15' sty__='{{"strokeColor":"rgb(119,119,119)","fillColor":"rgb(170, 212, 255)","zIndex":"-1"}}' klass='nowrap-default-wrap_reverse items_center-end-stretch-default' left='{73}' top='{111}' width='{67}' height='{73}' stroke='{1}' svg.cfg='{[-2,["",0,0,2,43,0,17,10,0,52],"lib/res/arrows.svg.json"]}' data-from='auto4'></div>
  </div>
</div>
