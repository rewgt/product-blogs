Shadow Widget 框架概略介绍
------------------------

&nbsp;

Shadow Widget 是一个基于 React 的前端开发框架，聚焦于提供所见即所得可视化的 web 页设计器。本文从更原始角度，为童鞋们介绍 Shadow Widget 是什么样的轮子，及，创造它的初心。

本文创建于16年10月27日，17年5月9日迁移到拼文产品博客。

&nbsp;

## 1. React 观感

使用 React 快两年了，**这个框架既简单，又很复杂**，如果把它看作纯粹的虚拟 DOM，确实够简单，但用作框架，虚拟 DOM 仅与真实 DOM 对应，单凭它做不了多少事的，React 是一只亮闪闪的金碗，得有其它食材、配料，才能让华丽的吃相配得上饥肠辘辘的胃袋。

于是，我们用了 babel，有了 browerify 与 babelify，这几项让我们的吃相变优雅 —— 可以用 ES6 工程化方式做开发了。为避免性能问题，得引入 immutable 状态数据。然后，你将发现 react-router 无法忽略，该死的虚拟 DOM 树，只能上级管下级，一级一级组装，没有前端路由类工具还真不好玩。到这一步，恭喜你，你已经完全被套进来了，要么继续前进，要么彻底放弃，重点是那个函数式编程，除了将函数式风格更彻底的执行下去，你似乎无法回头。接下来是 flux 框架，认认真真的构造单向数据流机制吧，咱就选 reflux。请原谅我把事情简化，React 工具链上每个节点都有数十个同类工具，我选最简单的来讲，immutable 库主流的有四、五种，用它有侵入性，选一个就不能用另一个，导致它的上层工具也沾染互斥效应，flux 框架库主流有三、四种，大名鼎鼎还有 redux 等，也具备侵入性，渲染入口就一个，从深圳去北京，总不能脑袋坐飞机，分出身子乘火车吧。再就是 webpack，我着实不喜欢为增强某些功能，就引入把事情搞得无限复杂的东东，所以选择无脑的 browserify。

终归不爽，费劲折腾个把月，似乎只做了 jQuery 能做的事，jQuery 还有 UI 插件呢，React 的可视插件在哪？搜一搜，网上一大堆，真正纳入进来用，这个限、那个限，N 多前提条件，有心细琢磨，对不起时间投入，自己新写一个花不了多少精力，但所有构件都自己写，按常人思维，你肯定会反思，何苦来着，还不如退回 jQuery 呢！但事情远没结束，你还没有 ajax 接口，没用工具链处理 SASS，没有热加载，还没挂入 glup 压缩打包，还没借助 TypeScript 实施类型检查，ESLint、mocha/jsdom/mockery 等调测工具都还没用到呢。

请不要误解，我并不抱怨 React 自身，而是它现有的技术栈与工具链，React 还是非常优秀的。但它的工具链尚在春秋战国，过于发散、杂乱、低效，而且，**在严谨普适的方法论与直观易用之间，还没找到最佳平衡方式**。

## 2. 我造了个轮子

从去年（注：指 2015 年）12 月中旬到现在，我花了 10 个月时间开发 <a target="_blank" href="https://github.com/rewgt/shadow-server">shadow-widget</a>，今天正式发布第一个版本。自始至终，我相信我在造轮子，也坚信我造的轮子比已有的轮子更有价值，因为上述种种不爽，基本克服了。

先扼要介绍一下 shadow-widget：

> _ Shadow Widget 是一种可视化控件框架，它基于 react 技术，将 JSX 及虚拟 DOM 封装成一种易用、易继承、易管理的形式，使界面设计与业务逻辑获得良好分离，进而支持所见即所得的开发模式。_   
&nbsp;   
_ 从软件工具链角度看 Shadow Widget，它相当于集成 react、react-router、redux 这 3 者再整合可视化设计工具。这里只是简单对照 Shadow Widget 与类似软件的功能，帮助大家快速建立概念。实际上，Shadow Widget 在 React 的虚拟 DOM 基础上自成体系提供一套松耦合、易描述、易扩展，基于双源驱动的框架系统，而非将若干 React 工具进行简单组合。_

更细节的内容请参考 <a target="_blank" href="https://rewgt.github.io/shadow-server/public/static/files/rewgt/doc/doc_zh/github_doc.html">Shadow Widget 用户手册</a>。

## 3. 框架的本质

前端框架是另一层面的编程语言，探究框架的本质之前，不妨先看看编程语言的本质。

最早期的计算机语言是纸带输入，然后是汇编，然后 fortan、C 等过程语言，再往后是面向对象语言、可视化编程语言、脚本语言等等。编程语言的发展历程始终围绕着两个核心：**效率、人性**，像最早期的穿孔纸带，极端低效、极端不人性，一点儿也不像机器伺候人，反倒是人在伺候机器，在面向对象语言出现后，编程语言的效率与人性化，才进入从量变到质变的跃升阶段。

![穿孔纸带输入](md/res/D170509-01/input_method.jpg)

就前端开发而言，框架是 MVC 使用方式的 “编程语言”，选择框架就是选择一种编程范式。如何评判一种框架，套用邓老一句名言，**不管黑框架还是白框架，能提升效率与人性的都是好框架**。

我非常赞同要以实用主义态度看待一个框架，就像尤雨溪（Vue 作者）曾说过：

> _ “英文里面有一个词叫 Pragmatism，就是实用主义。在简洁的同时，Vue 也强调使用者实现想做事情的目的。可以说，最早 Vue 是非常看重这一点的，我们也增加了很多类似于方便性质的 API，比如说过滤器。” &nbsp;&nbsp;  —— 图灵访谈：以匠人的态度不断打磨 Vue _

评价 Shadow Widget 时，我也希望大家不要简单的以是不是 FP、合不合乎 FRP 等来区分优劣，应该回到原点，有了 “效率与人性化” 的需求，才派生出 <a target="_blank" href="https://en.wikipedia.org/wiki/Visual_programming_language">Visual programming</a>、<a target="_blank" href="https://en.wikipedia.org/wiki/Functional_programming">Functional programming</a>、<a target="_blank" href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional reactive programming</a> 等理念，而不是反过来。

## 4. 分离 JSX

JSX 是 React 世界的幻术，它用来描述用户界面，看上去是静态的、声明式的，但，这是表象，本质上 JSX 是函数，而且是纯正的函数，比如：

```
  render() {
    return <p data-name="{myName}">example</p>;
  }
```

系统实际运行的是：

```
  render() {
    // where is myName? I don't know   :)
    return React.createElement('p',{'data-name':myName},'example');
  }
```

JSX 与上下文紧密相关，界面不是描述出来，而是编程出来的，这导致 React 构件形态在可理解、可复用方面，相比 Angular、Vue 等声明式风格差了很多。习惯用 Vue 的人初学 React，明显感觉 React 就是一团浆糊，想让界面重用（或快速修改），不得不对相关上下文语境探查一番。

为克服这个障碍，首先我们把 JSX 分离出来，用一种类 JSX 的表达方式来描述界面，Shadow Widget 用 **“转义标签”**，如：

```
  <div $=P key='txt' data-name='{"default name"}'>example</div>
```

用 `$=P` 指示使用 `p` 标签，属性值 `{"default name"}` 以首尾花括号表示它是 JSON 数据，导入时系统自动解读成 `data-name="default name"`。

分离后的界面，最后还得在 React 虚拟 DOM 树中作用回去，这么定义：

```
main['.body.top.txt'] = {
  $onClick: function(event) {
    alert('clicked!');
  },
};
```

路径 `'.body.top.txt'` 指示前面用转义标签声明的界面，定义体中 `$onClick` 函数是 DOM 节点的 onclick 事件回调函数。这个就是 Shadow Widget 的 **“投影定义”**，除了事件函数，其它如 `getInitialState, componentDidMount` 等都可以在此定义。现在，您想到了什么？Delphi 的界面定义在 `*.dfm` 文件，函数实现在 `*.pas` 文件，Qt 的界面定义在 `*.ui`，实现在 `*.cpp`，类似的，我们的界面用转义标签在 `*.html` 编写，函数实现在 `*.js` 文件，我们成功让小两口离婚了。

## 5. 双源驱动

React 渲染单向性主要体现在两方面，一是从父节点推导子节点，`props.children` 作为子层定义，逐级向下推导，二是各节点从传入的 `props.attr` 到 `state.attr`，再到 render 输出界面行为，也是单向推导的。

Shadow Widget 引入 **“双源属性”**（`duals.attr`）的概念，经封装后的 React 节点成为一种可复用构件，`duals.attr` 表达了这种构件对外公开的行为定义，也就是说，从 `props.attr` 推导界面行为的过程，可以简化理解成从 `props.attr` 推导 `duals.attr` 的过程。

“双源属性” 是一种可定制 getter、setter 函数的属性，对它赋值自带动作（调用 setter 函数）。duals 属性支撑了 “双源驱动” 的理念，可解决 React 技术栈现存的若干困局：

1) 把过程推导转变为属性值变迁控制

> 如前举例，把 JSX 从函数调用栈中抽离出来，成为指令式描述体后，JSX 中的变量引用怎么办（如例子中 `myName` 变量）？JSX 引用的变量通过一系列复杂推导的计算过程放哪儿？

> React 的渲染输出是 `render()` 函数中一段过程定义，其过程处理具备 FP 风格，非静态的，现在，我们插入若干可称为属性的观察点（可理解为临时静态），避免非得在一个调用栈中编写一段代码（如果那样，我们永远无法把 JSX 抽离出来），也就是说，不要在 `render()` 函数中编程了，改在 `duals.attr` 编程，`render()` 函数则固定为一定的处理方式。

> 但 `duals.attr` 是单项属性，怎么表达一段运算过程？我们要借助 `duals.attr` 的 setter 定义机制，还有其它数据联动、单流向传递等机制，这里不展开讲。

2) 让 FLUX 机制触手可及

> 从父节点推导子节点是 React 原生形态，实际产品运行往往很复杂，子节点变化可能影响父节点，还有广泛存在的情况是，两个互不隶属的节点相互影响。React flux 机制构造可预测单向数据流模型，是有效的应对方法。

> Shadow Widget 提供与 react flux、reflux、redux 近似功能，但更简便，**在主流 flux 方案中，应该找不到比我们更简单的了**（当然不以缺失功能为代价）。因为 Shadow Widget 内建 W 树，让索引与关联更便利，`dual.attr` 自带的可叠加定义 setter，也能方便 listen、unlisten，各种关联状态能自动维护。没有 “action, reducer, store” 等概念，少杀伤一些脑细胞。

> 关键是，`duals.attr` 具有 “临时静态” 特质，让开发者既能以 “上帝” 的视角安排作业，还不破坏函数式开发风格（打个比喻，还可化身为代码一份子，与周围小伙伴一起愉快的玩耍）。同类工具在处理这个问题时普遍很纠结，易用性与严谨性两者难以取舍，比如，使用 redux 时，会不会常有 “思维打结” 的感觉？如果有，应该 get 我的意思了。

3) duals 机制支持了可计算属性，可计算属性支持了条件渲染与循环渲染

> 类似 Angular 或 Vue 那样，在标签中可添加各种控制指令，让 Shadow Widget 做起来，相当简便，因为可计算属性的值是一条脚本表达式，脚本怎么写很灵活的。

## 6. 让转义标签支持 JS 表达式

可计算属性是转义标签中，预设的 **“一个可动态计算的 JS 脚本表达式”**，我拿同类工具作对比，说明它是干什么的。

在 Vue 中，`v-if` 与 `v-else` 用来动态控制某个节点是否显示，`v-for` 用来控制某列表内容循环显示。在 Angular 中，这几项对应于 `ng-if, ng-else, ng-repeat`。Shadow Widget 支持同样功能，比如针对列表项循环，排序、过滤等功能一样不少。

Shadow Widget 用一个微型解释器（MJI）构造沙盒运行环境，然后随时解析转义标签中的可计算表达式。它用 MJI 解释器应对变化，而不是固定预置若干指令，保证了延伸、定制能力，Vue 也支持自定义指令，但通过调用 API 注册后实现。

## 7. 可视化开发

有了转义标签与双源驱动，用户界面设计就能以所见即所得的方式支持起来了，如下图，创建一个构件时，只需从右侧资源列表中拖入一个样板，样板用图片表示，一眼就能看出它是什么构件。

![拖入样板创建构件](md/res/D170509-01/book_sample.png)

在设计区，选中新创建的构件，可立即修改各项属性值，属性变化后界面立即生效。

![属性页](md/res/D170509-01/property.png)

比如，我们想调大选中构件的字号，点击上图输入框 `"default-large-small"` 下方的 “Shift name” 按钮，当前构件立即把字号调大（通过 class 项改用 `"large-small-default"` 来实现）。

## 8. 跨越前端可视化设计的鸿沟

因工作关系，多年来我一直在寻找一款好用的 Web 页可视化设计器，结果很失望，没有一款有价值的。要么应用面限制在很窄范围，只对特定设计有意义，要么，如果面向通用可视化设计，全部是玩具，如果把具有基础可用性的工具打 80 分，当前那些做得最好的也只能打 30 分（Shadow Widget 不包含在内哟 `^v^`）。

HTML 从 V1 发展到 V5，都以 “在 html 文件中书写各式标签” 为设计背景逐步演进的，它天生不以支撑可视化设计为目标。当我们要设计一款工具，让它象 Delphi 或 QT 那样通过鼠标拖拉、点击，选配各个属性，来进行 WYSWYG 设计时，HTML 标签化设计与我们的目标隔了一条鸿沟，十多年过去了，没啥大进展。

解决这个难题的正确姿势是，先找出鸿沟，搞清楚鸿沟缺什么，然后才能建立有效的应对策略。任何试图单刀直入，强行硬上的做法都走不通，最好情况无非市面上多一款能打 30 分的玩具而己。

依我个人理解，这条鸿沟有两个重点：**“前端编程范式”** 与 **“自省能力”**。

举几个例子解释编程范式，比如，HTML 标签大致划分行内与块两类（严格来说，还有 table、list-item、inline-block 等，为简化起见都先视作 block 变种），但把这两类应用于产品界面设计，明显还缺 “布局” 一个层次，尽管 CSS 属性 `flex` 与 `float` 也用作布局，但依附于标签的设计风格，与我们从可视化设计出发的视角不同，独立服务于布局的品类是缺失的。Shadow Widget 采用面板（Panel 类构件）、段落（P 类构件）与行内（Span 类构件）来组织界面设计，让面板 Panel 专项提供布局能力。

再比如，导航结构在界面编程中广泛使用，下图左边栏是导航页，点击各项将在右侧打开相应页面，而右侧又分页显示，点击各个页标签，将切换到相应的内容页。

![导航结构](md/res/D170509-01/wiki.png)

react-router 用 URL 导航响应此类需求，Shadow Widget 则用 “可选导航”，把导航面板、选项构件、场景面板组合起来使用。这也是一种编程范式，有别于常规软件实现，范式要解决通用的一类问题，有一定适用面、可柔性伸展，归纳总结基础上稍有拔高，能让使用者触类旁通，把学习成本降下来。

Shadow Widget 较好的支持了四大构件关系，包括：顺序、包含、导航、层叠，大部分 Web 开发能从容应对了。没支持到也不要紧，因为 DOM 与 javascript 体系是开放的，React 也是开放的，Shadow Widget 没直接支持，可尝试用原生 React，React 也没支持，改用网页原生技术总可以了吧。只要 Shadow Widget 体系中的范式模型，能覆盖 95% 的应用开发，它的 WYSWYG 设计器就具备良好可用性了。

可视设计的 “自省能力”，是指被编辑对象的自我感知能力，就像一种蛇，喜欢用嘴含着自己的尾巴，但不会把自己吞下去，因为它具备 “自省能力”。

![自省蛇](md/res/D170509-01/snake.jpg)

在 Shadow Widget 可视设计器中，被编辑产品的 UI 界面真实的展现在设计区，但编辑操作是可视设计器提供的。一项操作，比如在产品 UI 上点击，系统怎么知道这个产品自身的点击操作，还是设计器发出的编辑动作，又如，某个节点被删除，怎么区分这是产品自身功能，还是设计器的编辑操作。

React 系统中所有构件都只由两项参数决定，一是 React Class，二是 props 配置，选择不同 React Class，或更改 props 取值，便是编辑操作的全部。借助虚拟 DOM 的隔离性，编辑只针对虚拟 DOM（而非真实 DOM），一方面，被编辑的 UI 数据化了，另一方面，还让 “编辑数据” 与 “应用数据”（以便更新 UI）成为相对独立的过程，两者分别为产品的 “数据面” 与 “应用面”。在可视设计中，产品 UI 与设计器同时运行，前者呈现 “数据面” 给后者，这相当于我们有了一个全新维度，“自省” 浑然天成。

实际效果在 Shadow Widget 已得到检验，比如 undo 与 redo，若没有虚拟 DOM，根本做不出严谨、可靠的功能，还有，弹窗编辑器可定制特性也是。

如下图，在可视设计器中选中一个构件，一排操作按钮自动浮现在构件上方，点击某按钮将召唤一个弹窗编辑器。弹窗编辑器完全开放供定制，像颜色选择器、日历、Markdown 编辑器什么的，用来立即编辑当前构件的属性数据。

![浮动按钮](md/res/D170509-01/float_btns.png)

因为编辑针对 “数据面”，供定制调用的接口很规范，什么都能定制，各式各样的弹窗编辑器都能扩展，所以，其它可视编辑工具只有收窄适用面，成为专用工具才做得好，本工具不会受此局限。

## 9. 适应技术分层与人员分工

Shadow Widget 有两大设计目标，其一是前面已介绍的可视化开发，其二是适应前端开发中的技术分层与人员分工。

七、八年前前端开发还是很简单的，一个新员工稍作培训马上能动手做开发，现在前端新人至少培养半年，才能真正上手。在薪资上，目前招聘一个 React 工程师，与只会旧技术的前端人员相比，价格差不多高出一倍，尽管这些年前端技术有了很大发展，但真到了非得用高薪人才能解决的地步吗？显然不是，我们仍有大量 Web 页开发没什么技术含量的，低技术要求部分被高要求部分绑架了。

Shadow Widget 将前端开发划分为两大部分：构件（Widget）开发与界面（GUI）开发。前者要求分发者具备完整技能，后者则只需简单技能，即：会用 html、css、javascript，掌握 react 入门知识，借助界面可视化设计器很快就能胜任工作。也就是说，我们预设前端开发人员至少可分两类，一类是入门级的，实习生水准，他主要工作是拿别人已开发好的构件搭积朩，另一类是高级工程师，他为前一类开发者开发构件。

技术分层与人员分工是一个组织高效运作的重要条件，不幸的是，现有 React 工具链对此缺少有效解决方案，Shadow Widget 奔这个痛点来了。

## 10. Shadow Widget 的容量

当前 Shadow Widget 版本经 minify 处理后，大小为 228 kb，作为参考，React.min.js 大小为 148 kb，可见，Shadow Widget 库不算太大，当然也不算小，相对于它提供的功能，这个库还算精简。采用 Shadow Widget 后就不必用 react-router、redux、immutable.js 了，另外，它还提供一套基于若干范式的可视构件库，是特有的。如果组合现有几个库来提供对等的功能，我相信，最终交付的 lib 会比 Shadow Widget 大不少。

如果采用 gzip 发布，React 加上 Shadow Widget 的库总尺寸应小于 100 kb，所以，本技术体系的交付件尺寸不应成为负担。

Shadow Widget 容量较大，代码规模已是 React 的 2 倍，学习份量也不轻，目前中文版手册已经完整了，建议要学就系统的去学，手册从头到尾全盘看下来。屠龙技要配屠龙刀，刀的份量轻了，屠不了龙，呃，这个工具有点复杂，祝大家好运！

&nbsp;
<!-- SLIDE PAGES V1.0, DO NOT CHANGE THIS LINE. -->
<div $=ScenePage key='auto0'></div>
<div $=ScenePage key='auto1' no-show='1'>
  <div $=".pinp.doc_info.thumb" no-show='' left='{-169}' top='{-109}' sty__='{{"background":"url(md/res/D170509-01/snake.jpg) no-repeat center","backgroundSize":"100% 100%"}}' klass='default-large-small p1-p2-p3-p0 visible-auto-hidden default-align_center-right' data-group.optid='pinp/blogs/step4' width='{280}' height='{200}'></div>
</div>
